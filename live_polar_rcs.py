#!/usr/bin/env python3
"""
Live polar plot of radar cross section (RCS) using the TinyRad board.

This script continuously captures range profiles from the TinyRad 24 GHz radar
and displays them on a polar plot.  When a baseline CSV (environment only)
is provided, the script computes the difference between each new measurement
and the baseline, effectively showing the RCS change due to an R‑fiducial
tag.  The plot updates until you terminate the program with Ctrl+C.

Example usage:

    # Run in the TinyRad Software/v6/Python directory
    source venv/bin/activate

    # Start live polar plotting without baseline (absolute magnitude)
    python live_polar_rcs.py --frames 200 --mode off

    # Start live polar plotting relative to baseline.csv
    python live_polar_rcs.py --frames 200 --ref baseline.csv --mode on

Options:
    --mode   : Descriptive label for the current test (baseline/off/on).  This
               doesn’t alter the algorithm but will appear in the plot title.
    --ref    : Path to a baseline CSV file generated by measure_rcs.py.  If
               provided, the script computes and displays the difference in dB
               relative to the baseline.
    --frames : Number of frames to average per update.  Higher values
               improve SNR at the cost of slower updates.
    --nfft   : FFT length for range processing.  Must be a power of two.
    --sleep  : Optional pause (seconds) between updates.  Default is zero
               (updates as fast as data arrives).

Requirements:
    * This script must reside in the TinyRad ``Software/v6/Python`` directory
      so that ``Class/TinyRad`` can be imported without modification.
    * The TinyRad board should be connected over USB and configured for
      FMCW operation.  See measure_rcs.py for details on udev setup.
    * Matplotlib is used for plotting and must be installed in your
      virtual environment (pip install matplotlib).
"""

import sys
import os
import argparse
import csv
import time
import numpy as np
import matplotlib.pyplot as plt

# Add TinyRad library path: parent directory of this script
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

try:
    import Class.TinyRad as TinyRad
except ImportError as exc:
    print(
        "Error importing TinyRad library. Ensure live_polar_rcs.py is located in"
        " the TinyRad Software/v6/Python folder and that Class/TinyRad exists."
    )
    print(f"Original error: {exc}")
    sys.exit(1)


def configure_radar():
    """Configure the TinyRad for FMCW range profiling."""
    Brd = TinyRad.TinyRad('Usb')
    Brd.BrdRst()
    Brd.RfRxEna()
    Brd.RfTxEna(2, 100)  # TX2 with maximum power
    dCfg = {
        'fStrt': 24.00e9,
        'fStop': 24.25e9,
        'TRampUp': 128e-6,
        'Perd': 0.2e-3,
        'N': 128,
        'Seq': [1],
        'CycSiz': 4,
        'FrmSiz': 100,
        'FrmMeasSiz': 1,
    }
    Brd.RfMeas(dCfg)
    return Brd, dCfg


def acquire_frames(Brd, n_frames):
    """Read ``n_frames`` consecutive frames from the board and return a stacked array."""
    data = []
    for _ in range(n_frames):
        data.append(Brd.BrdGetData())
    return np.stack(data, axis=2)  # shape = (N+1, channels, frames)


def compute_range_profile(frames, fs, slope, nfft):
    """
    Compute the magnitude of the range profile in dB from raw TinyRad frames.

    :param frames: ndarray of raw frames (N+1, channels, frames)
    :param fs: sampling rate (Hz)
    :param slope: chirp slope (Hz/s)
    :param nfft: FFT length (power of two)
    :return: (range_axis_m, mag_db)
    """
    data = frames[1:, :, :]  # drop frame counter row
    n_samples, n_channels, n_frames = data.shape
    window = np.hanning(n_samples).reshape(n_samples, 1)
    scale_win = np.sum(window)
    data_win = data * window[:, :, None]
    # FFT
    fft_out = 2 * np.fft.fft(data_win, n=nfft, axis=0) / scale_win
    fft_out = fft_out[:nfft // 2, :, :]
    mag = np.abs(fft_out)
    mag_mean = mag.mean(axis=(1, 2))
    mag_db = 20 * np.log10(mag_mean + 1e-12)
    c0 = 299792458.0
    rng_axis = np.arange(nfft // 2) / nfft * fs * c0 / (2 * slope)
    return rng_axis, mag_db


def load_baseline(csv_path):
    """Load a baseline magnitude profile from a CSV file and return (range, mag_db)."""
    ranges = []
    mags = []
    with open(csv_path, 'r', newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            if not row or row[0].startswith('#'):
                continue
            if row[0] == 'range_m':
                continue
            try:
                ranges.append(float(row[0]))
                mags.append(float(row[1]))
            except (ValueError, IndexError):
                continue
    return np.array(ranges), np.array(mags)


def main():
    parser = argparse.ArgumentParser(
        description="Live polar plotting of TinyRad range profiles.  Press Ctrl+C to stop."
    )
    parser.add_argument(
        '--mode',
        choices=['baseline', 'off', 'on'],
        default='baseline',
        help='Label for the current measurement (appears in plot title).'
    )
    parser.add_argument(
        '--ref', type=str,
        help='Reference CSV file for baseline subtraction (optional).'
    )
    parser.add_argument(
        '--frames', type=int, default=50,
        help='Number of frames to average per update (higher means smoother plot).'
    )
    parser.add_argument(
        '--nfft', type=int, default=4096,
        help='FFT length for range processing (power of two).'
    )
    parser.add_argument(
        '--sleep', type=float, default=0.0,
        help='Pause in seconds between updates (default: no pause).'
    )
    args = parser.parse_args()

    # Configure radar
    Brd, dCfg = configure_radar()
    fs = Brd.Get('fs')
    slope = (dCfg['fStop'] - dCfg['fStrt']) / dCfg['TRampUp']

    # Load baseline if provided
    ref_rng = ref_mag = None
    if args.ref:
        if not os.path.isfile(args.ref):
            print(f"Reference file {args.ref} not found; proceeding without baseline.")
        else:
            ref_rng, ref_mag = load_baseline(args.ref)
            if ref_rng.size == 0:
                print(f"Warning: reference file {args.ref} seems empty; ignoring it.")
                ref_rng = ref_mag = None
            else:
                print(f"Loaded baseline from {args.ref}")

    # Set up polar plot in interactive mode
    plt.ion()
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection='polar')
    ax.set_theta_zero_location('N')  # 0° at top (North)
    ax.set_theta_direction(-1)       # Clockwise direction
    # Initial empty line
    line, = ax.plot([], [], lw=2)
    ax.set_rlabel_position(0)  # radial labels at 0°

    try:
        while True:
            frames = acquire_frames(Brd, args.frames)
            rng_axis, mag_db = compute_range_profile(frames, fs, slope, args.nfft)
            # Compute relative difference if baseline loaded
            if ref_rng is not None:
                # Interpolate baseline onto our range axis
                ref_interp = np.interp(rng_axis, ref_rng, ref_mag,
                                       left=ref_mag[0], right=ref_mag[-1])
                diff_db = mag_db - ref_interp
                amp_lin = 10 ** (diff_db / 20.0)
            else:
                amp_lin = 10 ** (mag_db / 20.0)
            # Normalise amplitude for plotting (avoid huge dynamic range)
            amp_norm = amp_lin / (amp_lin.max() + 1e-12)
            # Create angles evenly spaced around full circle
            theta = np.linspace(0.0, 2.0 * np.pi, len(amp_norm), endpoint=False)
            # Update plot data
            line.set_data(theta, amp_norm)
            # Adjust radial axis limits dynamically
            ax.set_rlim(0, 1.1)
            ax.set_title(f"Live RCS polar plot (mode: {args.mode})")
            fig.canvas.draw()
            fig.canvas.flush_events()
            # Optional pause
            if args.sleep > 0.0:
                time.sleep(args.sleep)
    except KeyboardInterrupt:
        print("\nInterrupted by user. Closing...")
    finally:
        # Cleanup: close plot and release the board
        plt.ioff()
        plt.close(fig)
        del Brd


if __name__ == '__main__':
    main()